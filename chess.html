<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modern Chess Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@300;400;500;600&display=swap');
    
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow-x: hidden;
      position: relative;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(120, 219, 226, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100vw;
      max-width: 100vw;
      padding: 20px;
    }
    
    .game-title {
      font-family: 'Cinzel', serif;
      font-size: 3rem;
      font-weight: 700;
      color: #ffffff;
      text-align: center;
      margin-bottom: 2rem;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
      background: linear-gradient(135deg, #ffffff 0%, #a8a8a8 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .board-container {
      position: relative;
      padding: 30px;
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      border-radius: 20px;
      box-shadow: 
        0 25px 50px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(255, 255, 255, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      border-radius: 12px;
      overflow: hidden;
      width: 90vw;
      max-width: 500px;
      aspect-ratio: 1/1;
      box-shadow: 
        0 15px 35px rgba(0, 0, 0, 0.6),
        inset 0 0 0 2px rgba(255, 255, 255, 0.1);
      position: relative;
    }
    
    .board::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #8b5cf6, #06b6d4, #10b981, #f59e0b);
      border-radius: 14px;
      z-index: -1;
      opacity: 0.6;
      animation: borderGlow 3s ease-in-out infinite;
    }
    
    @keyframes borderGlow {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 0.9; }
    }
    
    .cell {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 3rem;
      cursor: pointer;
      position: relative;
      user-select: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .white {
      background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
      color: #2d3748;
    }
    
    .black {
      background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
      color: #f7fafc;
    }
    
    .cell:hover {
      transform: scale(1.02);
      z-index: 10;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    
    .selected {
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
      color: #1f2937 !important;
      box-shadow: 
        0 0 30px rgba(251, 191, 36, 0.8),
        inset 0 0 0 3px rgba(255, 255, 255, 0.3);
      transform: scale(1.05);
      z-index: 15;
      animation: selectedPulse 2s ease-in-out infinite;
    }
    
    @keyframes selectedPulse {
      0%, 100% { box-shadow: 0 0 30px rgba(251, 191, 36, 0.8), inset 0 0 0 3px rgba(255, 255, 255, 0.3); }
      50% { box-shadow: 0 0 40px rgba(251, 191, 36, 1), inset 0 0 0 3px rgba(255, 255, 255, 0.5); }
    }
    
    .move-dot {
      position: absolute;
      width: 35%;
      height: 35%;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(34, 197, 94, 0.9) 0%, rgba(34, 197, 94, 0.6) 100%);
      top: 32.5%;
      left: 32.5%;
      pointer-events: none;
      z-index: 5;
      box-shadow: 
        0 0 15px rgba(34, 197, 94, 0.5),
        inset 0 0 10px rgba(255, 255, 255, 0.2);
      animation: moveDotPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes moveDotPulse {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.1); opacity: 1; }
    }
    
    .check {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
      color: white !important;
      box-shadow: 
        0 0 30px rgba(239, 68, 68, 0.8),
        inset 0 0 0 3px rgba(255, 255, 255, 0.3);
      animation: checkPulse 1s ease-in-out infinite;
    }
    
    @keyframes checkPulse {
      0%, 100% { box-shadow: 0 0 30px rgba(239, 68, 68, 0.8), inset 0 0 0 3px rgba(255, 255, 255, 0.3); }
      50% { box-shadow: 0 0 40px rgba(239, 68, 68, 1), inset 0 0 0 3px rgba(255, 255, 255, 0.5); }
    }
    
    /* Enhanced piece styling */
    .cell {
      text-shadow: 
        2px 2px 4px rgba(0, 0, 0, 0.5),
        0 0 10px rgba(255, 255, 255, 0.3);
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    }
    
    .white .cell {
      text-shadow: 
        2px 2px 4px rgba(0, 0, 0, 0.3),
        0 0 8px rgba(0, 0, 0, 0.2);
    }
    
    #msg {
      color: #ffffff;
      font-size: 1.5rem;
      font-weight: 600;
      text-align: center;
      margin: 2rem 0 1rem 0;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      padding: 15px 30px;
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(147, 51, 234, 0.1) 100%);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #newgame {
      display: block;
      margin: 1.5rem auto;
      font-size: 1.1rem;
      font-weight: 600;
      padding: 15px 35px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      color: white;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 
        0 10px 25px rgba(139, 92, 246, 0.3),
        0 0 0 1px rgba(255, 255, 255, 0.1);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    #newgame:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 15px 35px rgba(139, 92, 246, 0.4),
        0 0 0 1px rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
    }
    
    #newgame:active {
      transform: translateY(0);
    }
    
    .player-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-bottom: 2rem;
      font-size: 1.2rem;
      font-weight: 500;
    }
    
    .player-turn {
      padding: 10px 20px;
      border-radius: 8px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ffffff;
      backdrop-filter: blur(10px);
    }
    
    .player-turn.active {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.4);
    }
    
    @media (max-width: 600px) {
      .game-title {
        font-size: 2rem;
        margin-bottom: 1rem;
      }
      
      .board-container {
        padding: 20px;
      }
      
      .board {
        width: 95vw;
        max-width: 95vw;
      }
      
      .cell {
        font-size: 1.8rem;
      }
      
      #msg {
        font-size: 1.1rem;
        margin: 1rem 0;
        padding: 10px 20px;
      }
      
      #newgame {
        font-size: 1rem;
        padding: 12px 25px;
      }
      
      .player-indicator {
        font-size: 1rem;
        margin-bottom: 1rem;
      }
    }
    
    @media (max-width: 400px) {
      .cell {
        font-size: 1.5rem;
      }
      
      .game-title {
        font-size: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="game-title">Royal Chess</h1>
    
    <div class="player-indicator">
      <div class="player-turn active" id="white-indicator">⚪ White's Turn</div>
      <div class="player-turn" id="black-indicator">⚫ Black's Turn</div>
    </div>
    
    <div class="board-container">
      <div class="board" id="board"></div>
    </div>
    
    <div id="msg"></div>
    <button id="newgame" style="display:none;">New Match</button>
  </div>
  
  <script>
const boardEl = document.getElementById("board");
const msgEl = document.getElementById("msg");
const newGameBtn = document.getElementById("newgame");
const whiteIndicator = document.getElementById("white-indicator");
const blackIndicator = document.getElementById("black-indicator");

const initialBoard = [
  ["r", "n", "b", "q", "k", "b", "n", "r"],
  ["p", "p", "p", "p", "p", "p", "p", "p"],
  ["", "", "", "", "", "", "", ""],
  ["", "", "", "", "", "", "", ""],
  ["", "", "", "", "", "", "", ""],
  ["", "", "", "", "", "", "", ""],
  ["P", "P", "P", "P", "P", "P", "P", "P"],
  ["R", "N", "B", "Q", "K", "B", "N", "R"]
];

const pieces = {
  r: "♜", n: "♞", b: "♝", q: "♛", k: "♚", p: "♟",
  R: "♖", N: "♘", B: "♗", Q: "♕", K: "♔", P: "♙"
};

let boardState, selected, currentPlayer, gameOver, legalMoves, flipped;

function resetGame() {
  boardState = JSON.parse(JSON.stringify(initialBoard));
  selected = null;
  currentPlayer = "white";
  gameOver = false;
  legalMoves = [];
  flipped = false;
  msgEl.textContent = "Game Started! White moves first.";
  newGameBtn.style.display = "none";
  updatePlayerIndicator();
  renderBoard();
}

function updatePlayerIndicator() {
  if (currentPlayer === "white") {
    whiteIndicator.classList.add("active");
    blackIndicator.classList.remove("active");
  } else {
    blackIndicator.classList.add("active");
    whiteIndicator.classList.remove("active");
  }
}

function isWhite(piece) {
  return piece && piece === piece.toUpperCase();
}

function isBlack(piece) {
  return piece && piece === piece.toLowerCase();
}

function getKingPos(color) {
  for (let r = 0; r < 8; r++)
    for (let c = 0; c < 8; c++)
      if (boardState[r][c] === (color === "white" ? "K" : "k"))
        return {row: r, col: c};
  return null;
}

// Returns true if the king of color is in check
function isCheck(color, state = boardState) {
  const king = getKingPos(color);
  if (!king) return false;
  const enemy = color === "white" ? "black" : "white";
  // For each enemy piece, see if it can move to king
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = state[r][c];
      if (p && ((enemy === "white" && isWhite(p)) || (enemy === "black" && isBlack(p)))) {
        if (isValidMove({row: r, col: c}, king, true, state)) return true;
      }
    }
  }
  return false;
}

// Returns true if color is checkmated
function isCheckmate(color) {
  if (!isCheck(color)) return false;
  // For each piece of color, if any legal move avoids check, not mate
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = boardState[r][c];
      if (p && ((color === "white" && isWhite(p)) || (color === "black" && isBlack(p)))) {
        const moves = getLegalMoves({row: r, col: c});
        if (moves.length > 0) return false;
      }
    }
  }
  return true;
}

// Returns true if move is legal (optionally skip turn/color check)
function isValidMove(from, to, ignoreTurn = false, state = boardState) {
  const piece = state[from.row][from.col];
  const target = state[to.row][to.col];
  if (!piece) return false;
  if (!ignoreTurn) {
    if ((currentPlayer === "white" && !isWhite(piece)) || (currentPlayer === "black" && !isBlack(piece))) return false;
    if (target && ((isWhite(piece) && isWhite(target)) || (isBlack(piece) && isBlack(target)))) return false;
  } else {
    if (target && ((isWhite(piece) && isWhite(target)) || (isBlack(piece) && isBlack(target)))) return false;
  }
  const dr = to.row - from.row;
  const dc = to.col - from.col;
  switch (piece.toLowerCase()) {
    case "p": {
      const direction = isWhite(piece) ? -1 : 1;
      // Move forward
      if (dc === 0 && !target && dr === direction) return true;
      // First move double
      if (dc === 0 && !target && dr === 2 * direction && ((from.row === 6 && isWhite(piece)) || (from.row === 1 && isBlack(piece))) && !state[from.row + direction][from.col]) return true;
      // Capture
      if (Math.abs(dc) === 1 && dr === direction && target && ((isWhite(piece) && isBlack(target)) || (isBlack(piece) && isWhite(target)))) return true;
      return false;
    }
    case "r":
      if (dr !== 0 && dc !== 0) return false;
      for (let i = 1; i < Math.max(Math.abs(dr), Math.abs(dc)); i++) {
        const r = from.row + (dr ? i * Math.sign(dr) : 0);
        const c = from.col + (dc ? i * Math.sign(dc) : 0);
        if (state[r][c]) return false;
      }
      return true;
    case "n":
      return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2);
    case "b":
      if (Math.abs(dr) !== Math.abs(dc)) return false;
      for (let i = 1; i < Math.abs(dr); i++) {
        const r = from.row + i * Math.sign(dr);
        const c = from.col + i * Math.sign(dc);
        if (state[r][c]) return false;
      }
      return true;
    case "q":
      if (dr === 0 || dc === 0) {
        for (let i = 1; i < Math.max(Math.abs(dr), Math.abs(dc)); i++) {
          const r = from.row + (dr ? i * Math.sign(dr) : 0);
          const c = from.col + (dc ? i * Math.sign(dc) : 0);
          if (state[r][c]) return false;
        }
        return true;
      }
      if (Math.abs(dr) === Math.abs(dc)) {
        for (let i = 1; i < Math.abs(dr); i++) {
          const r = from.row + i * Math.sign(dr);
          const c = from.col + i * Math.sign(dc);
          if (state[r][c]) return false;
        }
        return true;
      }
      return false;
    case "k":
      if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) {
        // Don't allow king to move into check
        let temp = JSON.parse(JSON.stringify(state));
        temp[to.row][to.col] = temp[from.row][from.col];
        temp[from.row][from.col] = "";
        if (isCheck(isWhite(piece) ? "white" : "black", temp)) return false;
        return true;
      }
      return false;
    default:
      return false;
  }
}

// Get all legal moves for a piece at position
function getLegalMoves(from) {
  const piece = boardState[from.row][from.col];
  if (!piece) return [];
  let moves = [];
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      if (isValidMove(from, {row: r, col: c})) {
        // Simulate move, check if king is in check after move
        let temp = JSON.parse(JSON.stringify(boardState));
        temp[r][c] = temp[from.row][from.col];
        temp[from.row][from.col] = "";
        if (!isCheck(currentPlayer, temp)) {
          moves.push({row: r, col: c});
        }
      }
    }
  }
  return moves;
}

// Flipped board rendering: flip after every move
function renderBoard() {
  boardEl.innerHTML = "";
  let rows = [...Array(8).keys()];
  let cols = [...Array(8).keys()];
  if (flipped) {
    rows = rows.reverse();
    cols = cols.reverse();
  }
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const row = rows[i];
      const col = cols[j];
      const cell = document.createElement("div");
      cell.classList.add("cell");
      cell.classList.add((row + col) % 2 === 0 ? "white" : "black");
      if (selected && selected.row === row && selected.col === col) {
        cell.classList.add("selected");
      }
      // Highlight king in check
      if (boardState[row][col] && ((currentPlayer === "white" && boardState[row][col] === "K" && isCheck("white")) ||
          (currentPlayer === "black" && boardState[row][col] === "k" && isCheck("black")))) {
        cell.classList.add("check");
      }
      cell.dataset.row = row;
      cell.dataset.col = col;
      const piece = boardState[row][col];
      if (piece) {
        cell.textContent = pieces[piece];
      }
      // Show move dots
      if (legalMoves && legalMoves.some(m => m.row === row && m.col === col)) {
        const dot = document.createElement("div");
        dot.className = "move-dot";
        cell.appendChild(dot);
      }
      boardEl.appendChild(cell);
    }
  }
}

boardEl.addEventListener("click", (e) => {
  if (gameOver) return;
  const cell = e.target.closest(".cell");
  if (!cell) return;
  const row = parseInt(cell.dataset.row);
  const col = parseInt(cell.dataset.col);
  if (isNaN(row) || isNaN(col)) return;
  if (selected) {
    // If clicked on a legal move, move
    if (legalMoves.some(m => m.row === row && m.col === col)) {
      boardState[row][col] = boardState[selected.row][selected.col];
      boardState[selected.row][selected.col] = "";
      selected = null;
      legalMoves = [];
      // Flip board after move
      flipped = !flipped;
      currentPlayer = currentPlayer === "white" ? "black" : "white";
      updatePlayerIndicator();
      renderBoard();
      
      // Check for checkmate
      if (isCheckmate(currentPlayer)) {
        gameOver = true;
        const winner = currentPlayer === "white" ? "Black" : "White";
        msgEl.textContent = `🎉 ${winner} wins by checkmate! 🎉`;
        newGameBtn.style.display = "block";
        return;
      }
      // Show check message
      if (isCheck(currentPlayer)) {
        msgEl.textContent = `⚠️ ${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} is in check!`;
      } else {
        msgEl.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
      }
      return;
    }
    // Deselect if clicked elsewhere
    selected = null;
    legalMoves = [];
    renderBoard();
  } else {
    const piece = boardState[row][col];
    if (piece && ((currentPlayer === "white" && isWhite(piece)) || (currentPlayer === "black" && isBlack(piece)))) {
      selected = { row, col };
      legalMoves = getLegalMoves(selected);
      renderBoard();
    }
  }
});

newGameBtn.onclick = resetGame;

resetGame();
  </script>
</body>
</html>